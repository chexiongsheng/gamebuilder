// ==================== Puerts Polyfill for V8 API Compatibility ====================
// This polyfill provides compatibility layer for existing V8-based JavaScript code
// to work with Puerts without modification.

(function (globalThis) {
  'use strict';

  // ==================== Console API ====================
  if (typeof console === 'undefined') {
    globalThis.console = {};
  }

  console.log = function (...args) {
    if (globalThis.__handleLog) {
      globalThis.__handleLog.Invoke('log', args.map(a => String(a)).join(' '));
    }
  };

  console.warn = function (...args) {
    if (globalThis.__handleLog) {
      globalThis.__handleLog.Invoke('warn', args.map(a => String(a)).join(' '));
    }
  };

  console.error = function (...args) {
    if (globalThis.__handleLog) {
      globalThis.__handleLog.Invoke('error', args.map(a => String(a)).join(' '));
    }
  };

  console.assert = function (condition, ...args) {
    if (!condition) {
      const message = args.length > 0 ? args.map(a => String(a)).join(' ') : 'Assertion failed';
      console.error('Assertion failed:', message);
      if (globalThis.__handleError) {
        globalThis.__handleError.Invoke('Assertion failed: ' + message, new Error().stack || '');
      }
    }
  };

  // ==================== Actor Property Accessors ====================

  // Boolean accessors
  globalThis.getActorBoolean = function (actorId, fieldId) {
    if (!globalThis.__getActorBoolean) {
      throw new Error('getActorBoolean callback not registered');
    }
    return globalThis.__getActorBoolean.Invoke(actorId, fieldId);
  };

  globalThis.setActorBoolean = function (actorId, fieldId, value) {
    if (!globalThis.__setActorBoolean) {
      throw new Error('setActorBoolean callback not registered');
    }
    globalThis.__setActorBoolean.Invoke(actorId, fieldId, Boolean(value));
  };

  // Float accessors
  globalThis.getActorFloat = function (actorId, fieldId) {
    if (!globalThis.__getActorFloat) {
      throw new Error('getActorFloat callback not registered');
    }
    return globalThis.__getActorFloat.Invoke(actorId, fieldId);
  };

  globalThis.setActorFloat = function (actorId, fieldId, value) {
    if (!globalThis.__setActorFloat) {
      throw new Error('setActorFloat callback not registered');
    }
    globalThis.__setActorFloat.Invoke(actorId, fieldId, Number(value));
  };

  // Vector3 accessors
  globalThis.getActorVector3 = function (actorId, fieldId) {
    if (!globalThis.__getActorVector3) {
      throw new Error('getActorVector3 callback not registered');
    }
    // C# out parameters need to be wrapped with $ref and unwrapped with $unref
    const outX = puer.$ref();
    const outY = puer.$ref();
    const outZ = puer.$ref();
    globalThis.__getActorVector3.Invoke(actorId, fieldId, outX, outY, outZ);
    return {
      x: puer.$unref(outX),
      y: puer.$unref(outY),
      z: puer.$unref(outZ)
    };
  };

  globalThis.setActorVector3 = function (actorId, fieldId, x, y, z) {
    if (!globalThis.__setActorVector3) {
      throw new Error('setActorVector3 callback not registered');
    }
	
    // Pass x, y, z as separate parameters
    globalThis.__setActorVector3.Invoke(
      actorId,
      fieldId,
      x,
      y,
      z
    );
  };

  // Quaternion accessors
  globalThis.getActorQuaternion = function (actorId, fieldId) {
    if (!globalThis.__getActorQuaternion) {
      throw new Error('getActorQuaternion callback not registered');
    }
    // C# out parameters need to be wrapped with $ref and unwrapped with $unref
    const outX = puer.$ref();
    const outY = puer.$ref();
    const outZ = puer.$ref();
    const outW = puer.$ref();
    globalThis.__getActorQuaternion.Invoke(actorId, fieldId, outX, outY, outZ, outW);
    return {
      x: puer.$unref(outX),
      y: puer.$unref(outY),
      z: puer.$unref(outZ),
      w: puer.$unref(outW)
    };
  };

  globalThis.setActorQuaternion = function (actorId, fieldId, x, y, z, w) {
    if (!globalThis.__setActorQuaternion) {
      throw new Error('setActorQuaternion callback not registered');
    }

    // Pass x, y, z, w as separate parameters
    globalThis.__setActorQuaternion.Invoke(
      actorId,
      fieldId,
      x,
      y,
      z,
	  w
    );
  };

  // String accessors
  globalThis.getActorString = function (actorId, fieldId) {
    if (!globalThis.__getActorString) {
      throw new Error('getActorString callback not registered');
    }
    return globalThis.__getActorString.Invoke(actorId, fieldId);
  };

  globalThis.setActorString = function (actorId, fieldId, value) {
    if (!globalThis.__setActorString) {
      throw new Error('setActorString callback not registered');
    }
    globalThis.__setActorString.Invoke(actorId, fieldId, String(value));
  };

  // ==================== Service Call API ====================

  // callVoosService - Main service call API (compatible with V8 engine)
  // Note: This is a synchronous-looking API but internally uses async callback
  // It's kept for backward compatibility with existing code
  globalThis.callVoosService = function (serviceName, ...args) {
    if (!globalThis.__callServiceAsync) {
      throw new Error('callServiceAsync callback not registered');
    }

    // For synchronous-looking API, we use a workaround:
    // Store result in a closure and return it synchronously
    // This works because Unity's main thread will process the callback immediately
    let result = undefined;
    let error = null;
    let completed = false;

    try {
      const argsJson = args.length > 0 ? JSON.stringify(args) : '[]';

      globalThis.__callServiceAsync.Invoke(serviceName, argsJson, function (resultJson) {
        completed = true;
        if (resultJson && resultJson !== '') {
          try {
            result = JSON.parse(resultJson);
          } catch (e) {
            result = resultJson;
          }
        }
      });

      // In Unity's single-threaded environment, the callback should execute immediately
      if (!completed) {
        console.error('callVoosService: callback not executed immediately');
      }

      return result;
    } catch (err) {
      console.error('callVoosService error:', err.message);
      throw err;
    }
  };

  // Legacy callback-based service call API
  globalThis.callService = function (serviceName, args, callback) {
    if (!globalThis.__callServiceAsync) {
      throw new Error('callServiceAsync callback not registered');
    }

    try {
      // Serialize arguments to JSON
      const argsJson = JSON.stringify(args || {});

      // Call C# service with async callback
      // Puerts will automatically convert JS function to C# delegate
      globalThis.__callServiceAsync.Invoke(serviceName, argsJson, function (resultJson) {
        try {
          // Parse result
          const result = resultJson ? JSON.parse(resultJson) : null;

          // Handle callback if provided
          if (typeof callback === 'function') {
            callback(result);
          }
        } catch (error) {
          console.error('callService callback error:', error.message);
          if (typeof callback === 'function') {
            callback(null, error);
          }
        }
      });
    } catch (error) {
      console.error('callService error:', error.message);
      if (typeof callback === 'function') {
        callback(null, error);
      }
      throw error;
    }
  };

  // Promise-based service call
  globalThis.callServiceAsync = function (serviceName, args) {
    return new Promise((resolve, reject) => {
      try {
        globalThis.callService(serviceName, args, (result, error) => {
          if (error) {
            reject(error);
          } else {
            resolve(result);
          }
        });
      } catch (error) {
        reject(error);
      }
    });
  };

  // handleError - Error handling API
  globalThis.handleError = function (error) {
    if (!globalThis.__handleError) {
      console.error('handleError callback not registered:', error);
      return;
    }

    if (typeof error === 'string') {
      globalThis.__handleError.Invoke(error, '');
    } else if (error && error.message) {
      globalThis.__handleError.Invoke(error.message, error.stack || '');
    } else {
      globalThis.__handleError.Invoke(String(error), '');
    }
  };

  // log - Logging API
  globalThis.log = function (...args) {
    const message = args.map(arg => {
      if (typeof arg === 'object') {
        try {
          return JSON.stringify(arg);
        } catch (e) {
          return String(arg);
        }
      }
      return String(arg);
    }).join(' ');

    if (globalThis.__handleLog) {
      globalThis.__handleLog.Invoke('log', message);
    }
  };

  // sysLog - System logging API (alias for log)
  globalThis.sysLog = function (...args) {
    const message = args.map(arg => {
      if (typeof arg === 'object') {
        try {
          return JSON.stringify(arg);
        } catch (e) {
          return String(arg);
        }
      }
      return String(arg);
    }).join(' ');

    if (globalThis.__handleLog) {
      globalThis.__handleLog.Invoke('log', message);
    }
  };

  // ==================== Global Error Handler ====================

  globalThis.addEventListener = globalThis.addEventListener || function () { };
  globalThis.removeEventListener = globalThis.removeEventListener || function () { };

  // Capture unhandled errors
  const originalErrorHandler = globalThis.onerror;
  globalThis.onerror = function (message, source, lineno, colno, error) {
    if (globalThis.__handleError) {
      const errorMessage = error ? error.message : String(message);
      const stackTrace = error ? error.stack : `at ${source}:${lineno}:${colno}`;
      globalThis.__handleError.Invoke(errorMessage, stackTrace);
    }

    if (originalErrorHandler) {
      return originalErrorHandler.apply(this, arguments);
    }
    return false;
  };

  // ==================== Utility Functions ====================

  globalThis.assert = function (condition, message) {
    console.assert(condition, message);
  };

  // ==================== Initialization ====================

  console.log('[Polyfill] V8 compatibility layer loaded');

})(typeof globalThis !== 'undefined' ? globalThis : this);
